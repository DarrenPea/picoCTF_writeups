# buffer overflow 2

- [Description](#description)
- [Approach](#approach)
- [Flag](#flag)

## Description

Control the return address and arguments. <br>
Additional details will be available after launching your challenge instance.

This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](https://artifacts.picoctf.net/c/144/vuln)?
You can view source [here](https://artifacts.picoctf.net/c/144/vuln.c). And connect with it using `nc saturn.picoctf.net 61403`

## Approach

In the `vuln()` function, it uses `gets(buf)` and `puts(buf)`, which are vulnerable functions in C as they are vulnerable to buffer overflows since they allow more input than what `buf` is able to store.

```c
void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}
```

As such, I can overflow the return address to return to the `win()` function. However, it seems that the `win()` functions requires 2 arguments and it has to correspond to `0xCAFEF00D` AND `0xF00DF00D`.

```c
void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}
```

The layout of the stack would be as follows just before `win()` is called. (the stack grows downwards)

<table>
  <tr>
    <td style="text-align: center;">arg 2</td>
  </tr>
  <tr>
    <td style="text-align: center;">arg 1</td>
  </tr>
    <td style="text-align: center;">return pointer</td>
  </tr>
    <td style="text-align: center;">win() pointer</td>
  </tr>
    <td style="text-align: center;">...</td>
  </tr>
    <td style="text-align: center;">input</td>
  </tr>
</table>

As such, after overwritting with the `win()`pointer, I will have to overwrite the return pointer, before overwriting the values for `arg1` and `arg2`. Since it is a 32-bit executable, the return pointer will be 8 bytes long.

First, I will find the offset to the return address that I intend to overwrite using GDB.

```
gef➤  pattern create 150
[+] Generating a pattern of 150 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
```

Then, I run the program, providing the above pattern as the input. It seems that the program encounters a segmentation fault as the return address has been changed to `0x62616164` instead of `main()`.

<p align="center">
  <img src="https://raw.githubusercontent.com/DarrenPea/picoCTF_writeups/refs/heads/main/picoCTF-2022/Binary-Exploitation/buffer-overflow-2/img/offset.png" />
</p>

As such, I can find the offset to the location of the return address using `pattern search`.

```
gef➤  pattern search 0x62616164
[+] Searching for '64616162'/'62616164' with period=4
[+] Found at offset 112 (little-endian search) likely
```

I wrote `script.py` to overwrite the return address to `win()`, add a random 8 bytes value to fill the return pointer, and satisfy the conditions to read `flag.txt` using the offset value of 112.

## Flag

`picoCTF{argum3nt5_4_d4yZ_27ecbf40}`