# buffer overflow 0

- [Description](#description)
- [Approach](#approach)
- [Flag](#flag)

## Description

Let's start off simple, can you overflow the correct buffer? The program is available [here](https://artifacts.picoctf.net/c/173/vuln). You can view source [here](https://artifacts.picoctf.net/c/173/vuln.c). <br>
Additional details will be available after launching your challenge instance.

Connect using:
nc saturn.picoctf.net 52316

## Approach

Our input is being read by the `get(buf1)` function. The `get` function is vulnerable to buffer overflows as it will read all characters even though `buf1` may not be able to store all of them.

```c
char buf1[100];
gets(buf1);
vuln(buf1);
```

This input is processed by the `vuln(buf1)` function, which copies the data in `buf1` and stores in a 16 bytes buffer, `buf2`. As a result, when the the `vuln` function tries to store more bytes than `buf2[16]` can store it will result in a segmentation fault.

```c
void vuln(char *input){
	char buf2[16];
    strcpy(buf2, input);
}
```

Once there is a segmentation fault, a signal handler has already been set up, which will print out the flag.

```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

// inside main
signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```

Providing `aaaabaaacaaadaaaaaaabaaaca` as the input, I obtained the flag.

## Flag

`picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}`