# Some Assembly Required 1

- [Description](#description)
- [Approach](#approach)
- [Flag](#flag)

## Description

http://mercury.picoctf.net:1896/index.html

## Approach

TLDR: The flag is stored in the `./JIFxzHyW8W` program so I headed to http://mercury.picoctf.net:1896/JIFxzHyW8W and looked for the flag in the program using `strings`.

Upon inspecting the webpage, I saved the JavaScript file in `original.js`. It can be seen that it is very unreadable so I decided to piece it together and save it as comments in `file.js`.

This portion of the code basically decreases index by `0x1d6` so indexing of the list will begin from `0x1d6` instead of `0x0`.
```js
const _0x4e0e = function(_0x553839, _0x53c021) {
    _0x553839 = _0x553839 - 0x1d6;
    let _0x402c6f = _0x402c[_0x553839];
    return _0x402c6f;
}
```

After that, there is a function that shifts the list until the sum is equivalent to `0x994c3`
```js
(function(_0x76dd13, _0x3dfcae) {
    const _0x371ac6 = _0x4e0e;
    while (!![]) {
        try {
            const _0x478583 = -parseInt(_0x371ac6(0x1eb)) + parseInt(_0x371ac6(0x1ed)) + -parseInt(_0x371ac6(0x1db)) * -parseInt(_0x371ac6(0x1d9)) + -parseInt(_0x371ac6(0x1e2)) * -parseInt(_0x371ac6(0x1e3)) + -parseInt(_0x371ac6(0x1de)) * parseInt(_0x371ac6(0x1e0)) + parseInt(_0x371ac6(0x1d8)) * parseInt(_0x371ac6(0x1ea)) + -parseInt(_0x371ac6(0x1e5));
            if (_0x478583 === _0x3dfcae)
                break;
            else
                _0x76dd13['push'](_0x76dd13['shift']());
        } catch (_0x41d31a) {
            _0x76dd13['push'](_0x76dd13['shift']());
        }
    }
}(_0x402c, 0x994c3));
```
I simplified the above code into the following.
```js
(function(ls_array, value) {   // (ls, 0x994c3) passed to it
    const extract_from_ls_by_i = extractor;
    while (!![]) {
        try {   // values below are replaced based on the last iteration before the loop breaks
            const total = 
            -parseInt('802698XOMSrr') + 
            parseInt('474547vVoGDO') + 
            -parseInt('2NIQmVj') * -parseInt('504454llVtzW') + 
            -parseInt('1195047NznhZg') * -parseInt('1qfevql') + 
            -parseInt('2wfTpTR') * parseInt('275341bEPcme') + 
            parseInt('43591XxcWUl') * parseInt('23SMpAuA') + 
            -parseInt('1699808QuoWhA');
            
            if (total === value)    // true for this substitution since it is based on the last iteration
                break;
            else
                ls_array['push'](ls_array['shift']());
        } catch (e) {
            ls_array['push'](ls_array['shift']());
        }
    }
}(ls, 0x994c3));
```

Then, there is some code that runs the program `./JIFxzHyW8W`, while instantiaing a WebAssembly instance.
```js
(async () => {
    const _0x48c3be = _0x4e0e;
    let _0x5f0229 = await fetch(_0x48c3be(0x1e9))
      , _0x1d99e9 = await WebAssembly[_0x48c3be(0x1df)](await _0x5f0229[_0x48c3be(0x1da)]())
      , _0x1f8628 = _0x1d99e9[_0x48c3be(0x1d6)];
    exports = _0x1f8628['exports'];
}
)();
```
And I proceeded to make sense of it below.
```js
(
async () => {
	const extract_from_ls_by_i = extractor;
    let _0x5f0229 = await fetch('./JIFxzHyW8W')
      , _0x1d99e9 = await WebAssembly['instantiate'](await _0x5f0229['arrayBuffer']())
      , _0x1f8628 = _0x1d99e9['instance'];
    exports = _0x1f8628['exports'];
}
)();
```

Lastly, it seems to be the portion that handles the button click to determine if the flag is correct.
```js
function onButtonPress() {
    const _0xa80748 = _0x4e0e;
    let _0x3761f8 = document['getElementById'](_0xa80748(0x1e4))[_0xa80748(0x1dd)];
    for (let _0x16c626 = 0x0; _0x16c626 < _0x3761f8['length']; _0x16c626++) {
        exports[_0xa80748(0x1d7)](_0x3761f8[_0xa80748(0x1ec)](_0x16c626), _0x16c626);
    }
    exports['copy_char'](0x0, _0x3761f8['length']),
    exports[_0xa80748(0x1e7)]() == 0x1 ? document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)] = _0xa80748(0x1e6) : document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)] = _0xa80748(0x1e8);
}
```
And I simplified it to become
```js
function onButtonPress() {
	const extract_from_ls_by_i = extractor;
	let user_input = document['getElementById']('input')['value'];
	for (let i = 0x0; i < user_input['length']; i++) {
		exports['copy_char'](user_input['charCodeAt'](i), i);
	}
    
    // copies input into WebAssembly memory and checks if flag is correct
	exports['copy_char'](0x0, user_input['length']),
	exports['check_flag']() == 0x1 ? document['getElementById']('result')['innerHTML'] = 'Correct!' : document['getElementById']('result')['innerHTML'] = 'Incorrect!';
}
```

After a thorough analysis of the above codes, I realised the flag is stored in `./JIFxzHyW8W`, before running the WebAssembly. Hence, I went to http://mercury.picoctf.net:1896/JIFxzHyW8W and obtained the WebAssembly file, which enabled me to obtain the flag.

```
$ strings JIFxzHyW8W
memory
__wasm_call_ctors
strcmp
check_flag
input
        copy_char
__dso_handle
__data_end
__global_base
__heap_base
__memory_base
__table_base
j!
  F!!A
!" ! "q!# #
!% $ %q!&
!( ' (q!) & )k!*
!+ +
        q!
+picoCTF{a2843c6ba4157dc1bc052818a6242c3f}
```

## Flag

`picoCTF{a2843c6ba4157dc1bc052818a6242c3f}`